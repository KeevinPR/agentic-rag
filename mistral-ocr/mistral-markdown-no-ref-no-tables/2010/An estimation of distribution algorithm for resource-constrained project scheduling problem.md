# An estimation of distribution algorithm for resource-constrained project scheduling problem 

Chen Fang, Ling Wang, Ye Xu<br>TNList, Department of Automation, Tsinghua University, Beijing, 100084<br>E-mail: \{fangchen06@mails.tsinghua.edu.cn; wangling@tsinghua.edu.cn; xuye05@mails.tsinghua.edu.cn\}

#### Abstract

An estimation of distribution algorithm (EDA) is proposed to solve resource-constrained project scheduling problem (RCPSP). In the EDA, individual is encoded based on the extended active list, and a probability model of the distribution for each activity in a project and its updating mechanism are proposed. The algorithm determines the initial probability matrix according to an initial set of solutions generated by the regret-based sampling method and priority rule, and decodes the individuals by using serial schedule generation scheme. Meanwhile, a permutation based local search method is incorporated into the algorithm to enhance the exploitation ability so as to further improve the searching quality. Simulation results based on benchmarks and comparisons with some existing algorithms demonstrate the feasibility and effectiveness of our proposed EDA.


Key Words: Estimation of distribution algorithm, Resource-constrained project scheduling, Probability model

## 1 INTRODUCTION

The resource-constrained project scheduling problem (RCPSP) is concerned with the scheduling of the project activities over time and resources [1]. So far, research on RCPSP has extended to a variety of engineering fields, such as manufacturing modeling, software development, railway scheduling, logistics, and so on [2].

The RCPSP is NP-hard, so classic mathematic methods can hardly solve the problems with large scale effectively. During the past decade, study on RCPSP with the intelligent optimization algorithms has gain increasing attention and rapid development. In [3], a permutation based genetic algorithm (GA) was proposed, which adopted regret-based sampling method and priority rule to produce initial population. In [4], an active list based GA was presented where a gene is used to decide either forward or backward schedule generation scheme (SGS) was used. In [5], an adaptive GA was proposed, which employed a gene to decide either parallel SGS or serial SGS was used to evaluate the individuals. In [6], an active list based simulated annealing (SA) was proposed, where serial SGS was used to generate schedule and insert operator was employed as local search strategy. In [7], a random key based SA was introduced, where some activities were delayed on purpose to expand search space. In [8], a global shift operator-based SA was proposed, which adopted multiple cooling chains with different initial solution. In [9], a forward-backward Tabu search (TS) was proposed to solve time-varying RCPSP, where active list and serial SGS were adopted. In [10], the abandoned solution was inserted based on a flow network model. In [11], TS was presented to solve RCPSP with schedule-dependent setup times, where a pre-processing procedure was used to delete all

[^0]inefficient modes, non-executable modes, and incapable locations. In [12], both permutation-based particle swarm optimization (PSO) and priority-based PSO were proposed. In [13], a combinatorial PSO algorithm was developed to solve multi-mode RCPSP, where a swap operator was used as local search and a penalty function was employed to estimate the infeasibility level of a particle solution.

Estimation of distribution algorithm (EDA) is a novel kind of evolutionary algorithms [14]. Different from GA, EDA generates new individuals according to a probability model but not with genetic operators, and good individuals are selected to update the probability model at each generation. As a newly proposed stochastic optimization algorithm, nowadays EDA has become a hot topic in field of evolutionary computation based optimization [15-18]. We refer [14] for more details about EDA. However, to the best of our knowledge, there has no EDA based research for RCPSP so far. Thus, we aim at developing an effective EDA based algorithm for solving RSPSP in this paper.

The remainder of the paper is organized as follows: In Section 2, RCPSP is described; in section 3, the EDA is proposed for RCPSP in detail; computational results and comparisons are listed in Section 4; and finally we end the paper with some conclusions in Section 5.

## 2 RESOURCE-CONSTRAINED PROJECT SCHEDULING PROBLEM

The RCPSP is to study the reasonable utilization of resource and the scheduling of project activities to optimize certain objective function. The RCPSP is of wide engineering background. The well-known job-shop, flow-shop and open-shop scheduling problems can be regarded as the special cases of the RCPSP.

The classic RCPSP can be stated as follows. A project consists $J$ activities that are labeled as $j=1, \ldots, J$, where the duration of activity $j$ is denoted by $d_{j}$. There are


[^0]:    This research is partially supported by NSFC (60774082, 70871065 and 60834004 ) and Program for New Century Excellent Talents in University (NCET).

precedence relations between some activities of project. The precedence relations are given by sets of immediate predecessors $P_{j}$ indicating that an activity $j$ may not be started before each of its predecessors $i \in P_{j}$ is completed. The set of renewable resources is referred as $K^{\rho}$. For each resource $k \in K^{\rho}$ the per-period-availability is assumed to be constant that is denoted by $R_{k}^{\rho}$. Activity $j$ requires $r_{j k}$ units of resource $k$ in each period of its non-preemptable duration $d_{j}$. The activities $j=0$ and $j=J+1$ are dummy activities, which represent the start and end of the project respectively. It assumes that the dummy activities do not request any resource and their durations are equal to zero. The set of all activities including the dummy activities is denoted as $J^{+}=\{0, \ldots, J+1\}$. The common used objective for the RCPSP is to minimize the makespan of the project, which is also considered in this paper.

The mathematic model for the RCPSP can be formulated as follows:

$$
\min \sum_{i=E F T_{j+1}}^{L F T_{j}} t \cdot x_{j+1, i}
$$

subject to

$$
\begin{aligned}
& \sum_{i=E F T_{j}}^{L F T_{j}} x_{j i}=1, j \in J^{+} \\
& \sum_{i=E F T_{k}}^{L F T_{j}} t \cdot x_{k i} \leq \sum_{i=E F T_{j}}^{L F T_{j}}\left(t-d_{j}\right) x_{j i}, j \in J^{+} ; h \in P_{j} \\
& \sum_{j=1}^{J^{+}, \min \{r=l,-1, E F T_{j}\}}^{r_{j k}, j=J^{+}, i, j} r_{j k} x_{j k} \leq N R_{k}, k \in R_{k}^{\rho} \\
& x_{j i}= \begin{cases}1, \text { if activity } j \text { finishes at time } t . \\
0, \text { otherwise. }\end{cases}
\end{aligned}
$$

where $L F T_{j}$ is the latest finish time of activity $j, E F T_{j}$ is t he earliest finish time of activity $j$.

## 3 EDA FOR RCPSP

In this section, the EDA for RCPSP is proposed after introducing solution representation, construction of the probability model, local search strategy, and learning based updating mechanism.

### 3.1 Individual representation and schedule generation scheme

Ideally, an individual representation should meet the following five conditions [19]: 1) The transformation between solutions should be computationally fast; 2) For each solution in the original space, there is a solution in the encoded space; 3) Each encoded solution corresponds to one feasible solution in the original space; 4) All solutions in the original space should be represented by the same number of encoded solutions; 5) Small changes in the encoded solution should result in small changes in the solution itself.

An extended activity list (EAL) is proposed in this paper, which contains three parts: an activity list (AL), a list with the start time of every activity $\left(s t_{0}, s t_{1}, s t_{2}, \cdots, s t_{n+1}\right)$ and a
list with the finish time of every activity $\left(f t_{0}, f t_{1}, f t_{2}, \cdots, f t_{n+1}\right)$. It concluded from experimental tests that procedures based on AL representations outperform the other procedures [20]. A list with the start (finish) time of every activity will be helpful when optimizing backward (forward) scheduling. The EDA does not operate on a schedule but on the EAL representation of a schedule. This character makes the algorithm convenient and effective for solving RCPSP.
![img-0.jpeg](img-0.jpeg)

Fig. 1. An example of RCPSP
With the above encoding mechanism, a schedule generation scheme (SGS) should be used to transform the representation to a schedule. When the EAL is changed (e.g. performing crossover), the three parts of EAL need to be synchronized with of SGS. When a new EAL is generated, SGS is used to evaluate the EAL. With the help of SGS, the EAL can satisfy the five conditions mentioned above easily.
![img-1.jpeg](img-1.jpeg)


Fig. 2. A schedule and its EAL
Consider a simple RCPSP illustrated in Fig. 1, a feasible schedule and its EAL represent are depicted in Fig. 2.

As for the SGS, there are two kinds in the literature, including serial SGS and parallel SGS. Contrary to the serial SGS, parallel SGS is sometimes unable to obtain an optimal schedule [21]. Thus, in our procedure the serial SGS is adopted.

### 3.2 Probability model

Different from GA that produces offspring through crossover and mutation operators, EDA does it by sampling according to a probability model. How to construct the probability model is the main issue when designing EDA, and the model has a great effect on the performances of EDA [22].

In this paper, the probability model is a following $n \times n$ probability matrix.

$$
\operatorname{Prob}(t)=\left(\begin{array}{ccc}
\operatorname{prob}_{i 1} & \cdots & \operatorname{prob}_{i j} \\
\vdots & \ddots & \vdots \\
\operatorname{prob}_{j 1} & \cdots & \operatorname{prob}_{j j}
\end{array}\right)
$$

where the element $\operatorname{prob}_{i i}$ represents the probability that the activity $j$ is put at place $i$ of the EAL at generation $t$.

In other words, $\operatorname{prob}_{j i}$ is an index to indicate how good it seems to put activity $j$ at the place $i$. At every position $i$, the selection probability of activity $j$, i.e. $P_{j i}$, is calculated according to probability matrix $\operatorname{Prob}(t)$ over the set of eligible activities, that is

$$
p_{j i}=\frac{\operatorname{prob}_{j i}}{\sum_{k=1}^{j} \operatorname{prob}_{k i}}
$$

If activity $j$ has already been placed in some position, the whole line $\operatorname{prob}_{j 1}, \operatorname{prob}_{j 2}, \ldots, \operatorname{prob}_{j j}$ of probabilistic matrix Prob is set zero.

### 3.3 Initial population

In our EDA, a regret-based biased random sample method [23] with priority rule is used to generate initial population. In particular, starting with an empty activity sequence, we obtain a job sequence with feasible precedence by repeatedly applying the following step: The next activity in the activity sequence is taken from the set of those currently unselected activities, all non-dummy predecessors of which have already been selected for the job sequence. We employ latest finish time (LFT) priority rule [24] to derive the probabilities that are used to select the next activity for the activity sequence at each decision stage.

Let $\eta_{j}$ be the probability of choosing activity $j$ that has a priority value $v_{j}$. The value of $\eta_{j}$ is calculated as follow:

$$
\begin{aligned}
& r_{j}=\max _{i \in D} v_{i}-v_{j} \\
& \eta_{j}=\frac{\left(r_{j}+\varepsilon\right)^{a}}{\sum_{i \in D}\left(r_{j}+\varepsilon\right)^{a}}
\end{aligned}
$$

LFT priority rule is adopted in our procedure, which has been validated to generate good schedules for RCPSP. The priority value $v_{j}$ is calculated for the eligible activities according to the following equation:

$$
v_{j}=\max _{i \in D} L F T_{i}-L F T_{j}+1
$$

where, $L F T_{j}$ is the latest finish time of activity $j, D$ in equation (8)-(10) is the set of eligible activities ready to be scheduled.

Kolisch found that the regret-based biased random sample method was of good performance when $\varepsilon=\alpha=1$ [25]. Accordingly, we also choose $\varepsilon=\alpha=1$ in our EDA.

### 3.4 Local search strategy

To enhance the exploitation ability, a permutation-based local search strategy PBLS controlled by a threshold Pper is proposed to explore the neighborhood of an individual. This operator is a variation of SWAP operator, but the PBLS does not break the feasibility of the EAL if the EAL
is feasible before performing local search. The procedure of PBLS is described as follows:

```
Procedure PBLS
    For \((i=1,2, \ldots, n)\)
    \{
        Randomly generate \(q\) where \(0<q<1\);
        If \((q<\) Pper \()\)
        \{
            If(EAL \((i)\) is not the predecessor for \(\operatorname{EAL}(i+1))\)
            \}
                Exchange \(\operatorname{EAL}(i)\) and \(\operatorname{EAL}(i+1)\);
                Evaluation the new EAL;
            \}
        \}
\}
```

Fig. 3. Procedure of PBLS

### 3.5 Forward-backward iteration

Forward-Backward Iteration (FBI) [26] is an effective technique for RCPSP. Basically, the procedure iteratively employs SGS forward and backward scheduling until no further improvement in the makespan of project can be found. The activity finish times (part 3 of EAL) of a forward schedule determine the activity priorities for the next backward schedule. Similarly, the activity start times (part 2 of EAL) of a backward schedule determine the activity priorities for the forward schedule. FBI can be easily incorporated into many algorithms for RCPSP to improve the solution quality. In Fig. 4, a single iteration step is used to illustrate the procedure of FBI.
![img-2.jpeg](img-2.jpeg)

Fig. 4. A single iteration step of FBI
To reduce the makespan of Fig. 2 FBI is used by shifting each activity to the right as much as possible, in decreasing order of activity end times. For example, activity 9 and activity 7 cannot be scheduled later. Activity 8 can be right shifted to start at time 15 . Activity 6 can be shifted two time units and start at time 10 . Since the right shift of activity 8 has made some additional resources available, activity 1 can be shifted three time units to start at time 9 . Activities 2, activity 3 and activity 5 can be shifted two time units. Finally, activity 4 is shifted to time 14 . In this way, we obtain a schedule with a makespan of 16 units. Further improvements of the schedule are possible by shifting activities as much as possible to the left. This process reduces the makespan by one further time unit, as illustrated at the bottom of Fig. 4.

### 3.6 Updating mechanism

In this paper, a population based updating mechanism is adopted to refresh the probabilistic matrix Prob. First, a number of Pop individuals are created according the matrix $P r o b$, and FBI is employed to renew every individual. Then the best $N$ individuals are chosen to update the probabilistic matrix Prob according to the following equation:

$$
\operatorname{prob}_{i t}(t+1)=(1-\beta) \cdot \operatorname{prob}_{j t}(t)+\frac{\beta}{N} \sum_{k=1}^{N} I_{j t}^{k},(i \geq 1 ; j \leq J)
$$

where $\beta$ is the learning speed and $I_{j t}^{k}$ is the indicator function. For the $k$ th individual, if activity $j$ is placed at position $i, I_{j t}^{k}=1$, else $I_{j t}^{k}=0$.

### 3.7 Procedure of EDA

With the above design, the procedure of EDA is summarized as follows.

```
Procedure EDA
Step 1. Generate an Initial population \(\left\{\pi_{1}, \ldots \pi_{\text {init_pop }}\right\}\)
    with regret-based sampling method and LFT.
Step 2. Apply FBI to \(\left\{\pi_{1}, \ldots \pi_{\text {init_pop }}\right\}\).
Step 3. Initialize probability matrix Prob with
    \(\left\{\pi_{1}, \ldots \pi_{\text {init_pop }}\right\}\), and then calculate all \(p_{j i}\).
Step 4. Generate a new population \(\left\{\pi_{1}, \ldots \pi_{\text {pop }}\right\}\)
    according to \(p_{j i}\).
Step 5. Apply FBI to \(\left\{\pi_{1}, \ldots \pi_{\text {pop }}\right\}\).
Step 6. Apply PBLS to the best \(N\) individuals of
    \(\left\{\pi_{1}, \ldots \pi_{\text {pop }}\right\}\).
Step 7. Update Prob with the best \(N\) individuals, and
    then calculate all new \(p_{j i}\).
Step 8. If the stopping condition is not met, go to Step 4.
```

Fig. 5. Procedure of EDA

## 4 COMPUTATIONAL EXPERIMENTS

We code the procedure in Visual C++ 2005 on IBM Thinkpad T61 with a Core 2 T7500 2.2GHz processor and use the well-known data sets PSPLIB for testing. This data set contains subsets J30, J60, J90, and J120 with problem instances of $30,60,90$, and 120 activities, respectively. In this paper, we use J30, J60, and J120 to test the performances of EDA and to compare with some existing algorithms in literature.

### 4.1 Parameter Settings

As for the parameter setting, we use the orthogonal method of design of experiment (DOE) to determine a set of suitable parameters for the proposed EDA. Since the J120 contains the hardest problems, we choose 60 instances from J120 to carry out the DOE test. Combinations of the parameter values in Table 1 are evaluated.

Due to the limitation of page requirement, we omit the details of the DOE. The best combination of parameters is as follow: the number of initial population Init_pop is fixed at 200; the population size of each generation Pop is set equal to 50 ; the number of individuals used to update the
probability matrix $N$ is fixed at $5(10 \% \mathrm{Pop})$; the learning speed $\beta$ is set equal to 0.1 ; the local search accept rate Pper is fixed at 0.8 .

Table 1. Combinations of parameter values
### 4.2 Computational results of EDA

For our experiments, we set the maximum number of generated schedules (500, 1000 and 5000) as the stopping condition. Table 2 lists the results obtained by running our proposed EDA 20 independent times for each instance. The performances include the average, minimum and maximum percentage deviation from the lower bounds as well as the variance of deviation. As for the lower bound, we use the theoretically optimal values for set J30 and employ the critical-path based lower bound for set J60 and set J120.

From Table 2, it can be seen that the derivation values increase as the size of the problem increases. It shows that RCPSP with large scale is more difficult to solve since the problem is NP-hard. For each set of problems, the derivation values decrease as the maximum number of generated schedules increases. It shows that more schedules are explored better results can be obtained. For J30, the results obtained by the proposed EDA are much close to the optimal bounds, so the EDA is very effective for RCPSP with small scale. In the next sub-section, we will compare our EDA with some existing algorithms to further show the effectiveness of our EDA. In addition, the variance values of deviation for all the sets are very small, which means that our EDA is very robust.

Table 2. Results overview of proposed EDA
### 4.3 Comparisons of EDA with existing algorithms

Next, we compare our EDA with some existing algorithms based on the PSPLIB data sets. Tables 3, Table 4, and Table 5 list the results of EDA and other algorithms in literature for data sets J30, J60, J120, respectively. Same as before, the average deviation from the optimal solution is

used as a measure of quality for J30 and the average deviation from the critical path based lower bound for J60 and J120.

Table 3. Average deviations (\%) for J30

Table 4. Average deviations (\%) for J60

From the these tables, it can be seen that among the 15 algorithms with 5000 generated schedules our EDA is the ninth best for J30 and is the sixth best for both J60 and J120. If only 1000 schedules are generated, our EDA procedure is the eighth, fifth, and third best heuristic among all the fifteen algorithms for J30, J60, and J120 respectively. The gaps between our EDA and the best algorithm for each set are very small. For the problem set J30, the gaps are $0.34 \%$ (1000 schedules) and $0.28 \%$ (5000 schedules); for J60, the gaps are $0.57 \%$ (1000 schedules) and $0.75 \%$ (5000 schedules); for J120, the gaps are $1.06 \%$ (1000 schedules)
and $2.10 \%$ (5000 schedules). So, it can be concluded that our EDA competitive to those well-performed existing algorithms, especially for large-scale problems. All in all, the EDA proposed in this paper is feasible, effective and robust for the RCPSP.

Table 5. Average deviations (\%) for J120

## 5 CONCLUSION

This was the first reported work about estimation distribution algorithm for solving the resource-constrained project scheduling problems. We encoded the individual of the problem based on extended active list, constructed the initial population by using a regret based sampling method and LFT priority rule, decoded the individual by using serial SGS, and applied a permutation based local search for exploitation. According to the DOE method, we determined a set of suitable values for parameter setting. Simulation results based on the PSPLIB benchmarks J30, J60, and J120 and comparisons with some existing algorithms demonstrated the effectiveness of the proposed EDA. The further work is to study the more suitable probability model of EDA and to develop adaptive EDA with learning mechanism and hybrid EDA with problem-dependent local search for RCPSP.
